# 学习笔记

## 区分全局变量和局部变量

把握位置，区分取变量的时机，以及变量当前的真实值

如，做 AI 假设胜负判断时，这时的棋盘状态是虚拟的，所以需要深拷贝，否则会影响当前棋盘状态。

## 关于对象拷贝

- JSON.parse(JSON.stringify(obj))
  完全深拷贝，但性能不好

- Object.create(obj)
  临时的浅拷贝

- {...obj}
- Object.assign({},obj)
- [...arr]

## 二维数组转一维数组

运算时，还是双 for 循环进行运算，只是将 X,Y 坐标用 3\*i+j 的形式替换

好处：避免了深拷贝的性能问题

## 如何来回切换 2 个值

利用不对称值的差值
如 1 + 2 = 3。
那么 3-x=y，x 既可以是 1，也可以 2，任何情况下都成立。
它在表示 棋类对战双方时，简单有效。

## 判断胜负逻辑引发的思考

1.罗列所有可能的场景
先用最笨的方式，概括所有场景

2.逻辑完成后，再考虑优化
如，判定横向胜负时，没必要循环所有横向场景，只需要考虑当前落子坐标的横向即可

## 博弈论

在对战中，双方的形势是对立的，除非最后判定和棋，之前都是为了胜利。所以衍生出一些策略

1.别输
从实际对战结果来看，该 3 子棋的策略是【别输】，优先考虑不让对方赢，却对于可以直接赢的情况有错过，可能是哪一步算法有问题，待解决。

2.博弈是互相的
对方最好策略就是我方最差，反之亦然。
如果在推导过程中发现对方的最优策略，那么直接占用该策略，我方即是最优策略。

## 递归的思考

递归就是函数调用自身，它和 while 相似，所以一定有个终止递归的逻辑判断，否则就是无限循环。

递归的过程可以直接用终止条件来判断，它的目的就是为了获取终止条件的状态（通常会返回某个状态），一层层递归直到拿到想要的状态或值。
这里的递归判断，是为了推导出对方会赢的落子点，然后反过来将其占用，从而使自己立于不败之地。

## 胜负剪枝

1.从代码上看，就是 break for 循环

2.是一种优化策略，适用所有循环逻辑判断。目的在于，一旦发现条件满足，后续代码就不需要执行了。
